/*
Gramatica para el Robot:
Autor: Alejandro Arango
Modificado por: Silvia Takahashi
Modificado por: Juan Pablo Morales.
Agregadas producciones para manejar globos
Modificado por Silvia Takahashi
Eliminadas producciones para manejar globos
Agregado el esqueleto para la traduccion
Modificado por Silvia Takahashi 
Re: Agregar Reglas para el manejo de globos
Modificado por Saulo Daza y Sonia Vivas
Modificado por Silvia Takahashi
Eliminadas reglas de traducci�n DE  MARCROS
Cambio del lenguaje de comandos
Modificado por Silvia Takahashi: algunas Reglas para traduccion
Modificado por Silvia Takahashi: Cambio en el lenguaje
Abril: 2008 - Simplificado apra solo interpretaci�n
 **/

options 
{
	LOOKAHEAD=1; 
	IGNORE_CASE=true;
	STATIC = false;
	
}
   

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import java.awt.Point;
import java.io.*;
import java.util.Vector;
import java.util.LinkedList;
import java.util.ArrayList;

@SuppressWarnings("serial")
public class Robot 
{


	private RobotWorldDec world;
	private ArrayList<String> variables = new ArrayList<String>();
	private ArrayList<Integer> valorvars = new ArrayList<Integer>();
	
	
	void setWorld(RobotWorld w) {
		world = (RobotWorldDec) w;	
	}

	String salida=new String();
}
PARSER_END(Robot)

SKIP:
{
	"\r"
	|	"\t"
//	| "\n"
}

TOKEN: /* Nombres de Comandos */
{

			<MOVE:  "move">
		| 	<TURNRIGHT: "turnright">
		| 	<PUT: "Put">
		| 	<PICK: "Pick">
		|  <POP: "Pop" >
		| < DEFVAR: "defvar">
		|  <EQUALS: "=" >
		|  <TURN: "turn" >
		|  <FACE: "face" >
		|  <MOVE_DIR: "move-dir" >
		|  <RUN_DIRS: "run-dirs" >
		|  <MOVE_FACE: "move-face" >
		|  <IF: "if" >
		|  <LOOP: "loop" >
		|  <REPEAT: "repeat" >
		|  <DEFUN: "defun" >
		|  <FACING_P: "facing-p" >
		|  <CAN_PUT: "can-put-p" >
		|  <CAN_PICK: "can-pick-p" >
		|  <CAN_MOVE: "can-move-p" >
		|  <NOT: "not" >
		| < PASS:"skip">
		|  <OP: "(" >
		|  <CP: ")" >
	
		

}

TOKEN :
{
		<NUMERO: (<DIGIT>)+ >
		|  	<#DIGIT: ["0"-"9"] >
}

TOKEN:
{
  	
  	< LETRA: ["a"-"z","A"-"Z"]>
 	| <DIGITO: ["0"-"9"] >
 	| < NAME: (< LETRA >)(< LETRA >|< DIGITO >)*>
 	//| < LETRA: (< letra >)(< letra >|< digito >)*>
}

TOKEN : /* PARAMETROS */
{
		<BALLOONS:  "balloons" >
		|	<CHIPS:     "chips"  >
		|  <RIGHT: "right" >
		|  <LEFT: "left" >
		|  <AROUND: "around" >
		|  <BACK: "back" >
		|  <FRONT: "front" >
		|  <NORTH: "north" >
		|  <SOUTH: "south" >
		|  <WEST: "west" >
		|  <EAST: "east" >

}


boolean command(StringBuffer sistema) :
	{	
		int x = 0;
		salida=new String();
		String[] nueva= new String[3];
		
	}
	
	{

		/*(
		   <TURNRIGHT> "(" ")" {world.turnRight();salida = "Command: Turnright";}
		| 	<MOVE>  "(" x=numero() ")" {world.moveForward(x);salida = "Command: Moveforward ";}  
	    | < DEFVAR> " " declararVariable(variables, valorvars) ")"
		) "\n" */ 
		instructions(x, salida, nueva) 

		{
		  //  try {
	    	//		 Thread.sleep(1);
	    	  //   } catch (InterruptedException e) {
	    		//	        System.err.format("IOException: %s%n", e);
	    		//	    }
	    			 
			sistema.append(salida);
			return true;
		}

     |  "\n" { return true; }

		| <EOF> {return false;} 
	}

void instructions(int x, String salida, String[] nueva):
{
  int p = 0;
 		
 }
{
  	
  	  <OP>
	(
   		<EQUALS> " " cambiarVariable(variables, valorvars) 
		| <MOVE>" " x=checkNum(variables, valorvars) //{world.moveForward(x);salida = "Command: Moveforward ";}
		| <TURN>":"(<LEFT>|<AROUND>|<RIGHT>) //{ world.moveHorizontally}
		| <FACE>":"(<SOUTH>|<WEST>|<EAST>|<NORTH>)
		| <PUT>":"(<BALLOONS>|<CHIPS>) x=checkNum(variables, valorvars)
		| <PICK>":"(<BALLOONS>|<CHIPS>) x=checkNum(variables, valorvars)
		| <MOVE_DIR> x=checkNum(variables, valorvars) (<FRONT>|<RIGHT>|<LEFT>|<BACK>)
		| <RUN_DIRS>(<FRONT>|<RIGHT>|<LEFT>|<BACK>)+ //FALTA QUE VUELVA A POSCICION ORIGINAL
		| <MOVE_FACE> x=checkNum(variables, valorvars) (<SOUTH>|<WEST>|<EAST>|<NORTH>)
		| <DEFVAR> " " declararVariable(variables, valorvars) //{variables[Integer.parseInt(nueva[0])]=nueva[1];valorvars[Integer.parseInt(nueva[0])]=Integer.parseInt(nueva[2]);}
		| <IF>condition()
		| alternos()

	)
	
	
	<CP>
    
}

void alternos(): { }
{
   <PUT> <OP> ":" (<CHIPS>|<BALLOONS>) <NUMERO> <CP>
|  <PICK><OP> ":" (<CHIPS>|<BALLOONS>) <NUMERO> <CP>
|  <MOVE><OP><NUMERO><CP>
|  <TURNRIGHT><OP><CP>
|  <POP><OP><NUMERO> <CP>
}



	int numero() throws Error:
	{
	  
		int total=1;
	}
	{
		<NUMERO>
		{
			try 
			{
				total = Integer.parseInt(token.image);
			} 
			catch (NumberFormatException ee) 
			{
				// Dada la forma de NUMERO, sabemos que solo puede tener d�gitos
				// Por lo tanto, lo unico que podria pasar es que el numero sea muy grande
				throw new Error("Number out of bounds: "+token.image+"!!");
			}
			return total;
		}
	}

	




void condition ():

{
}
{
 <OP>
(
  
 <FACING_P>" "(<SOUTH>|<WEST>|<EAST>|<NORTH>)
| <CAN_PUT_P>" "(<BALLOONS>|<CHIPS>) x=checkNum(variables, valorvars)
| <CAN_PICK_P>" "(<BALLOONS>|<CHIPS>) x=checkNum(variables, valorvars)
| <CAN_MOVE_P>" "(<SOUTH>|<WEST>|<EAST>|<NORTH>)
| <NOT> condition()
)
 <CP> 

}
void cambiarVariable(ArrayList<String> variables, ArrayList<Integer> valorvars) :
{
  int pos=-40;
  int i = 0;
  String pru = "";
}
{
  < NAME>
  {
    for(i=0; i<variables.size(); i++)
  	{
  	  pru = variables.get(i);
  	  if (pru!=null)
  	  { 
    	if(token.image.equals(pru))
    	{
    	  variables.remove(i);
    	  valorvars.remove(i);
    	  variables.add(token.image);
    	  pos = i;
    	}
  	  }
  	}
  	if(pos==-40)
  	{
  	  throw new Error("ERROR: NO EXISTE LA VARIABLE");

  	}
  	
  }
  " "
  < NUMERO>
  {
    valorvars.add(Integer.parseInt(token.image));
  }

}

int checkNum(ArrayList<String> variables, ArrayList<Integer> valorvars) :
{
  int rta = -57;
  int i = 0;
}
{
  (
    < NAME>
  {
    
  
  	for(i=0; i<variables.size(); i++)
  	{
    	if(token.image.equals(variables.get(i)))
    	{
    	  rta= valorvars.get(i);

    	}
  	}
  	if(rta == -57)
  	{
  	  throw new Error("ERROR: NO EXISTE LA VARIABLE");

  	}
  	return rta;
  }
	|  < NUMERO>
	{
	  rta=Integer.parseInt(token.image);
	  return rta; 
	}
	)
}




void declararVariable(ArrayList<String> variables, ArrayList<Integer> valorvars) :
	{
	  String nombre = "";
	  int total = 1;
	  int pos = 0;
	  int j = 0;
	  int k = 0;
	  
	}
	{
	  < NAME>
	  {
	    try 
			{
			  	variables.add(token.image);
				
			} 
			catch (NumberFormatException ee) 
			{
				// Dada la forma de NUMERO, sabemos que solo puede tener d�gitos
				// Por lo tanto, lo unico que podria pasar es que el numero sea muy grande
				throw new Error("NO PUDE METER EN EL ARRAY ESTO: "+token.image+"!!");
			}

	  }
	  " "
	  <NUMERO>
		{
			try 
			{
			  total = Integer.parseInt(token.image);
			  valorvars.add(total);
			  

				
			} 
			catch (NumberFormatException ee) 
			{
				// Dada la forma de NUMERO, sabemos que solo puede tener d�gitos
				// Por lo tanto, lo unico que podria pasar es que el numero sea muy grande
				throw new Error("Number out of bounds: "+token.image+"!!");
			}
			
			
		}
	}
	