/*
Gramatica para el Robot:
Autor: Alejandro Arango
Modificado por: Silvia Takahashi
Modificado por: Juan Pablo Morales.
Agregadas producciones para manejar globos
Modificado por Silvia Takahashi
Eliminadas producciones para manejar globos
Agregado el esqueleto para la traduccion
Modificado por Silvia Takahashi 
Re: Agregar Reglas para el manejo de globos
Modificado por Saulo Daza y Sonia Vivas
Modificado por Silvia Takahashi
Eliminadas reglas de traducci�n DE  MARCROS
Cambio del lenguaje de comandos
Modificado por Silvia Takahashi: algunas Reglas para traduccion
Modificado por Silvia Takahashi: Cambio en el lenguaje
Abril: 2008 - Simplificado apra solo interpretaci�n
 **/

options 
{
	LOOKAHEAD=1; 
	IGNORE_CASE=true;
	STATIC = false;
	
}
   

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import java.awt.Point;
import java.io.*;
import java.util.Vector;
import java.util.LinkedList;
import java.util.ArrayList;
import java.awt.Point;
//import control.Interpreter;

@SuppressWarnings("serial")
public class Robot 
{


	private RobotWorldDec world;
	private RobotWorld world2;
	//private Interpreter recursividad = new Interpreter();
	private ArrayList<String> variables = new ArrayList<String>(); 
	private ArrayList<Integer> valorvars = new ArrayList<Integer>();
	private ArrayList<String> tempnombres = new ArrayList<String>();
	private ArrayList<Integer> tempvalores = new ArrayList<Integer>();
	private ArrayList<String> blockfuns = new ArrayList<String>();
	private ArrayList<String> nombrefuns = new ArrayList<String>();
	private ArrayList<String> paramfuns = new ArrayList<String>();
	private ArrayList<String> tempnomdos = new ArrayList<String>();
	private String bloqueuno = "";
	private String bloquedos = "";
	private String elreturn = "";
	private String acumuresto = "";
	private int cuentaif = -1;
	void setWorld(RobotWorldDec w) {
		world = (RobotWorldDec) w;	
	}
	/*void setWorld2(RobotWorld w2) {
		world2 = (RobotWorld) w2;	
	}*/
	

	String salida=new String();
}
PARSER_END(Robot)

SKIP:
{
	"\r"
	|	"\t"
	| "\n"
}

TOKEN: /* Nombres de Comandos */
{

			<MOVE:  "move">
		| 	<TURNRIGHT: "turnright">
		| 	<PUT: "put">
		| 	<PICK: "pick">
		| < DEFVAR: "defvar">
		|  <EQUALS: "=" >
		|  <TURN: "turn" >
		|  <FACE: "face" >
		|  <MOVE_DIR: "move-dir" >
		|  <RUN_DIRS: "run-dirs" >
		|  <MOVE_FACE: "move-face" >
		|  <IF: "if" >
		|  <LOOP: "loop" >
		|  <REPEAT: "repeat" >
		|  <DEFUN: "defun" >
		|  <FACING_P: "facing-p" >
		|  <CAN_PUT_P: "can-put-p" >
		|  <CAN_PICK_P: "can-pick-p" >
		|  <CAN_MOVE_P: "can-move-p" >
		|  <NOT: "not" >
		|  <OP: "(" >
		|  <CP: ")" >
		|  <RESETVAR: "!!!" >
		| < SALTAR: "skip" >
		
	
		

}
TOKEN : /* PARAMETROS */
{
		<BALLOONS:  "balloons" >
		|	<CHIPS:     "chips"  >
		|  <RIGHT: "right" >
		|  <LEFT: "left" >
		|  <AROUND: "around" >
		|  <BACK: "back" >
		|  <FRONT: "front" >
		|  <NORTH: "north" >
		|  <SOUTH: "south" >
		|  <WEST: "west" >
		|  <EAST: "east" >

}

TOKEN :
{
		<NUMERO: (<DIGIT>)+ >
		|  	<#DIGIT: ["0"-"9"] >
}


TOKEN:
{
  	
  	< LETRA: ["a"-"z","A"-"Z"]>
 	| <DIGITO: ["0"-"9"] >
 	//| < NAME: (< LETRA >)(< LETRA >|< DIGITO >)*>
 	//| < LETRA: (< letra >)(< letra >|< digito >)*>
}




boolean command(StringBuffer sistema) :
	{	
		int x = 0;
		salida=new String();
		String[] nueva= new String[3];
		
	}
	
	{

		haceInput(x, salida, nueva) 

		{
		  //  try {
	    	//		 Thread.sleep(1);
	    	  //   } catch (InterruptedException e) {
	    		//	        System.err.format("IOException: %s%n", e);
	    		//	    }
	    			 
			sistema.append(salida);
			return true;
		}

     |  "po" { return true; }

		| <EOF> {return false;} 
	}

void haceInput(int x, String salida, String[] nueva):
{
  int p = 0;
  boolean bool;
  int q = 0;
  String busque = "";
  int sizee = 0;
  String cprespuesto = ")";
 }
{
  	
  	  <OP>
	(
   		<EQUALS> " " cambiarVariable(variables, valorvars) 
		| <MOVE>" " x=checkNum(variables, valorvars) {world.moveHorizontally(x);salida = "Command: Moveforward ";
														//this.ReInit(new java.io.StringReader(input));
														}
		| <SALTAR>
		| <TURN>" :"(<LEFT>|<AROUND>|<RIGHT>) //{world.moveVertically(1);salida = "Command: MoveALV ";}
		| <FACE>" :"(<SOUTH>|<WEST>|<EAST>|<NORTH>) //{world.moveVertically(2);salida = "Command: MoveALV ";}
		| <PUT>":"
					 (<BALLOONS>" "x=checkNum(variables, valorvars){world.putBalloons(x);}
					  |<CHIPS>" "x=checkNum(variables, valorvars){world.putChips(x);})
		| <PICK>":"(<BALLOONS>" "x=checkNum(variables, valorvars){world.grabBalloons(x);}
					  |<CHIPS>" "x=checkNum(variables, valorvars){world.pickChips(x);})
		| <MOVE_DIR> x=checkNum(variables, valorvars) (<FRONT>|<RIGHT>|<LEFT>|<BACK>)
		| <REPEAT > " "x=checkNum(variables, valorvars) " " { elreturn = "";}
					<OP> { acumuresto = "";}
					soloRevisaIf(x, salida, tempnombres, tempvalores)
					< CP> { System.out.println(elreturn);}
					< CP>
					{
					  if(!elreturn.equals(""))
			  		  { 
			  			acumuresto = "(";
			  			for(p=0; p<x;p++)
			  			{
			  			  acumuresto = acumuresto.concat("(");
			  			  acumuresto = acumuresto.concat(elreturn);
			  			  acumuresto = acumuresto.concat(")");
			  			}
			  			acumuresto = acumuresto.concat(")");
			  			elreturn="";
			  		  }
			  		}
			  		soloRevisaIf(x, salida, tempnombres, tempvalores)
					{
			  			if(!elreturn.equals(""))
			  			{ 
			  				acumuresto = acumuresto.concat("(");
			  				acumuresto = acumuresto.concat(elreturn);
			  				acumuresto = acumuresto.concat(")");
			  			}
			  			acumuresto = cprespuesto.concat(acumuresto);
			  			System.out.println(acumuresto);
			  			this.ReInit(new java.io.StringReader(acumuresto));
					}
			  		
		| <RUN_DIRS>(<FRONT>|<RIGHT>|<LEFT>|<BACK>)+ //FALTA QUE VUELVA A POSCICION ORIGINAL
		| <MOVE_FACE> x=checkNum(variables, valorvars) (<SOUTH>|<WEST>|<EAST>|<NORTH>)
		| < RESETVAR> {
		  				sizee = tempnomdos.size();
		  				for(p=0; p<tempnomdos.size(); p++)
						{
						  busque = tempnomdos.get(q);
						  for(q=0; q<variables.size(); q++)
						  {
						    if(busque.equals(variables.get(q)))
						    {
						      variables.remove(q);
						      valorvars.remove(q);
						      tempnomdos.remove(p);
						    }
						  }
						}
		  				}
		| <DEFVAR> " " declararVariable(variables, valorvars) //{variables[Integer.parseInt(nueva[0])]=nueva[1];valorvars[Integer.parseInt(nueva[0])]=Integer.parseInt(nueva[2]);}
		| < DEFUN> " " cargarFuncion(tempnombres, tempvalores, nombrefuns, paramfuns, blockfuns)
		| (<IF> (bool=condition())(< CP>)
			(<OP> { elreturn=token.image; acumuresto = "";}
			soloRevisaIf(x, salida, tempnombres, tempvalores) {bloqueuno=elreturn.concat(")"); }
			< CP>{ elreturn="";}
			)
			(<OP> { elreturn="";}
			soloRevisaIf(x, salida, tempnombres, tempvalores) {bloquedos=elreturn; }
			< CP>{ elreturn="";}
			)
			< CP>
			)
			soloRevisaIf(x, salida, tempnombres, tempvalores)
			{
			  if(!elreturn.equals(""))
			  { 
			  	acumuresto = "(";
			  	acumuresto = acumuresto.concat(elreturn);
			  	acumuresto = acumuresto.concat(")");
			  }
			  elreturn="";
			  if (bool)
			  {
			    bloqueuno = cprespuesto.concat(bloqueuno);
			    bloqueuno = bloqueuno.concat(acumuresto);
			    System.out.println(bloqueuno);
			    this.ReInit(new java.io.StringReader(bloqueuno));
			    bloqueuno = "";
			    bloquedos = "";
			    acumuresto = "";
			  }
			  else
			  {
			    bloquedos = cprespuesto.concat(bloquedos);
			    bloquedos = bloquedos.concat(acumuresto);
			    System.out.println(bloquedos);
			    this.ReInit(new java.io.StringReader(bloquedos));
			    bloqueuno = "";
			    bloquedos = "";
			    acumuresto = "";
			  }
			}
		| < OP> haceInputRecursion( x, salida, nueva)
		|buscarFuncion() 
		

	)
	
	
	<CP>
    
}

void haceInputRecursion(int x, String salida, String[] nueva):
{
  int p = 0;
  boolean bool;
  int q = 0;
  String busque = "";
  int sizee = 0;
 		
 }
{
  	
	(
   		<EQUALS> " " cambiarVariable(variables, valorvars) 
		| <MOVE>" " x=checkNum(variables, valorvars) {world.moveHorizontally(x);salida = "Command: Moveforward ";
														//this.ReInit(new java.io.StringReader(input));
														}
		| <SALTAR>
		| <TURN>" :"(<LEFT>|<AROUND>|<RIGHT>) //{world.moveVertically(1);salida = "Command: MoveALV ";}
		| <FACE>" :"(<SOUTH>|<WEST>|<EAST>|<NORTH>) //{world.moveVertically(2);salida = "Command: MoveALV ";}
		| <PUT>" :"
					 (<BALLOONS>" "x=checkNum(variables, valorvars){world.putBalloons(x);}
					  |<CHIPS>" "x=checkNum(variables, valorvars){world.putChips(x);})
		| <PICK>" :"(<BALLOONS>" "x=checkNum(variables, valorvars){world.grabBalloons(x);}
					  |<CHIPS>" "x=checkNum(variables, valorvars){world.pickChips(x);})
		| <MOVE_DIR> x=checkNum(variables, valorvars) (<FRONT>|<RIGHT>|<LEFT>|<BACK>)
		| <RUN_DIRS>(<FRONT>|<RIGHT>|<LEFT>|<BACK>)+ //FALTA QUE VUELVA A POSCICION ORIGINAL
		| <MOVE_FACE> x=checkNum(variables, valorvars) (<SOUTH>|<WEST>|<EAST>|<NORTH>)
		| < RESETVAR> {
		  				sizee = tempnomdos.size();
		  				for(p=0; p<tempnomdos.size(); p++)
						{
						  busque = tempnomdos.get(q);
						  for(q=0; q<variables.size(); q++)
						  {
						    if(busque.equals(variables.get(q)))
						    {
						      variables.remove(q);
						      valorvars.remove(q);
						      tempnomdos.remove(p);
						    }
						  }
						}
		  				}
		| <DEFVAR> " " declararVariable(variables, valorvars) //{variables[Integer.parseInt(nueva[0])]=nueva[1];valorvars[Integer.parseInt(nueva[0])]=Integer.parseInt(nueva[2]);}
		| < DEFUN> " " cargarFuncion(tempnombres, tempvalores, nombrefuns, paramfuns, blockfuns)
		| (<IF> (bool=condition())
			(<OP> { elreturn=""; acumuresto = "";}
			soloRevisaIf(x, salida, tempnombres, tempvalores) {bloqueuno=elreturn; }
			< CP>{ elreturn="";}
			)
			(<OP> { elreturn="";}
			soloRevisaIf(x, salida, tempnombres, tempvalores) {bloquedos=elreturn; }
			< CP>{ elreturn="";}
			)
			
			)
			soloRevisaIf(x, salida, tempnombres, tempvalores)
			{
			  acumuresto = elreturn;
			  elreturn="";
			  if (bool)
			  {
			    bloqueuno = bloqueuno.concat(acumuresto);
			    this.ReInit(new java.io.StringReader(bloqueuno));
			    bloqueuno = "";
			    bloquedos = "";
			    acumuresto = "";
			  }
			  else
			  {
			    bloquedos = bloquedos.concat(acumuresto);
			    this.ReInit(new java.io.StringReader(bloquedos));
			    bloqueuno = "";
			    bloquedos = "";
			    acumuresto = "";
			  }
			}
		| < OP> haceInputRecursion( x, salida, nueva)
		| buscarFuncion() 
		

	)
	
	
	<CP>
	[< OP>haceInputRecursion( x, salida, nueva)]
    
}
void buscarFuncion():
{
  int x=0;
  int y=0;
  boolean cheker=false;
  int indexxx= 0;
  String elnombre = "";
  String elsupernombre = "";
  int elnumero = 0;
  String input = "";
  String cpp= ")";
  
}
{
  (
    (< LETRA >{ elsupernombre=elsupernombre.concat(token.image);})(< LETRA >{ elsupernombre=elsupernombre.concat(token.image);}|< DIGITO >{ elsupernombre=elsupernombre.concat(token.image);})*
  
  )
  {
    try 
			{
			  	for(x=0; x<nombrefuns.size(); x++)
    			{
      				if(elsupernombre.equals(nombrefuns.get(x)))
      				{
      				  cheker=true;
      				  indexxx= x;
      				  input = blockfuns.get(x);
      				  try 
						{
						  	tempnombres = new ArrayList<String>();
							tempvalores = new ArrayList<Integer>();
							String[] tempvarss= paramfuns.get(indexxx).split(" ");
			  				for(y=0; y<tempvarss.length; y++)
			  				{
			  				  tempnombres.add(tempvarss[y]);
			  				  tempnomdos.add(tempvarss[y]);
			  				  tempvalores.add(-1);
			  				 }
						} 
					catch (NumberFormatException ee) 
						{
							// Dada la forma de NUMERO, sabemos que solo puede tener d�gitos
							// Por lo tanto, lo unico que podria pasar es que el numero sea muy grande
							throw new Error("NO PUDE METER EN EL ARRAY ESTO: "+token.image+"!!");
						}

      				}
     			}
     			if(!cheker)
     			{
     			  
     			  throw new Error("NO ENCONTRE ESA FUNCION... PAILA ");

     			}
			} 
			catch (NumberFormatException ee) 
			{
				// Dada la forma de NUMERO, sabemos que solo puede tener d�gitos
				// Por lo tanto, lo unico que podria pasar es que el numero sea muy grande
				throw new Error("NO PUDE METER EN EL ARRAY ESTO: "+token.image+"!!");
			}
  }
  " "
  (
    < NUMERO>
    {
      if(tempnombres.get(0)!=null) { 
        elnombre = tempnombres.get(0);
        elnumero = Integer.parseInt(token.image);
        tempnombres.remove(0);
        variables.add(elnombre);
        valorvars.add(elnumero);
      }
      else
      {
        throw new Error("NO HAY SUFICIENTES VARIABLES");
      }
      
    
	}  )
  (
    " "
    < NUMERO>
    { 
    if(tempnombres.get(0)!=null) { 
        elnombre = tempnombres.get(0);
        elnumero = Integer.parseInt(token.image);
        tempnombres.remove(0);
        variables.add(elnombre);
        valorvars.add(elnumero);
      }
      else
      {
        throw new Error("NO HAY SUFICIENTES VARIABLES");
      }
	}  )*
  < CP >
  {
    input = cpp.concat(input);
    //System.out.println(input);
    elreturn = "";
  }
  soloRevisaIf(x, salida, tempnombres, tempvalores) 
  {
    if(!elreturn.equals(""))
			  { 
			  	acumuresto = "(";
			  	acumuresto = acumuresto.concat(elreturn);
			  	acumuresto = acumuresto.concat(")");
			  }
    input = input.concat("(!!!)");
    input = input.concat(acumuresto);
    System.out.println(input);
    
    this.ReInit(new java.io.StringReader(input));
    //this.ReInit(new java.io.StringReader(elreturn));
  }
  
  
}

//void soloRevisa(int x, String salida, ArrayList<String> tempnombres, ArrayList<Integer> tempvalores):
//{
  //int p = 0;
  //boolean bool;
  //String elretur = "";
  //String amedias = "";
 		
 //}
//{
  	//(
  	  //<OP> { elreturn=elreturn.concat(token.image);}
	//(
   		//<EQUALS>{ elreturn=elreturn.concat(token.image);} " "{ elreturn=elreturn.concat(token.image);} cambiarVariable(tempnombres, tempvalores)
		//| <SALTAR>{ elreturn=elreturn.concat(token.image);}
		//| <MOVE>{ elreturn=elreturn.concat(token.image);}" "{ elreturn=elreturn.concat(token.image);} x=checkNum(tempnombres, tempvalores)
		//| <TURN>{ elreturn=elreturn.concat(token.image);}":"{ elreturn=elreturn.concat(token.image);}(<LEFT>|<AROUND>|<RIGHT>){elreturn=elreturn.concat(token.image);} 
		//| <FACE>{ elreturn=elreturn.concat(token.image);}":"{ elreturn=elreturn.concat(token.image);}(<SOUTH>|<WEST>|<EAST>|<NORTH>){ elreturn=elreturn.concat(token.image);}
		//| <PUT>{ elreturn=elreturn.concat(token.image);}" :"{ elreturn=elreturn.concat(token.image);}(<BALLOONS>|<CHIPS>) { elreturn=elreturn.concat(token.image);}" "{ elreturn=elreturn.concat(token.image);} x=checkNum(tempnombres, tempvalores)
		//| <PICK>{ elreturn=elreturn.concat(token.image);}" :"{ elreturn=elreturn.concat(token.image);}(<BALLOONS>|<CHIPS>){ elreturn=elreturn.concat(token.image);} " "{ elreturn=elreturn.concat(token.image);} x=checkNum(tempnombres, tempvalores)
		//| <MOVE_DIR>{ elreturn=elreturn.concat(token.image);} x=checkNum(tempnombres, tempvalores) (<FRONT>|<RIGHT>|<LEFT>|<BACK>){ elreturn=elreturn.concat(token.image);}
		//| <RUN_DIRS>{ elreturn=elreturn.concat(token.image);}(<FRONT>{ elreturn=elreturn.concat(token.image);}|<RIGHT>{ elreturn=elreturn.concat(token.image);}|<LEFT>{ elreturn=elreturn.concat(token.image);}|<BACK>{ elreturn=elreturn.concat(token.image);})+ 
		//| <MOVE_FACE> { elreturn=elreturn.concat(token.image);}x=checkNum(tempnombres, valorvars) (<SOUTH>|<WEST>|<EAST>|<NORTH>){ elreturn=elreturn.concat(token.image);}
		//| <DEFVAR> { elreturn=elreturn.concat(token.image);}" "{ elreturn=elreturn.concat(token.image);} declararVariable(tempnombres, valorvars) { elreturn=elreturn.concat(token.image);}//{variables[Integer.parseInt(nueva[0])]=nueva[1];valorvars[Integer.parseInt(nueva[0])]=Integer.parseInt(nueva[2]);}
		//| <IF>{ elreturn=elreturn.concat(token.image);}bool=condition()
		//| (soloRevisa(x, salida, tempnombres, tempvalores))+
	//)
	
	
		  //<CP>{ elreturn=elreturn.concat(token.image);}
	  
  //)
//}

void soloRevisaIf(int x, String salida, ArrayList<String> tempnombres, ArrayList<Integer> tempvalores):
{
  int p = 0;
  boolean bool;
  //String elretur = "";
  String amedias = "";
 		
 }
{
  		(  		  <EQUALS>{ elreturn=elreturn.concat(token.image);} " "{ elreturn=elreturn.concat(token.image);} cambiarVariable(tempnombres, tempvalores)
		| <MOVE>{ elreturn=elreturn.concat(token.image);}" "{ elreturn=elreturn.concat(token.image);} x=checkNum(tempnombres, tempvalores)
		| <SALTAR>{ elreturn=elreturn.concat(token.image);}
		| <TURN>{ elreturn=elreturn.concat(token.image);}":"{ elreturn=elreturn.concat(token.image);}(<LEFT>|<AROUND>|<RIGHT>){elreturn=elreturn.concat(token.image);} 
		| <FACE>{ elreturn=elreturn.concat(token.image);}":"{ elreturn=elreturn.concat(token.image);}(<SOUTH>|<WEST>|<EAST>|<NORTH>){ elreturn=elreturn.concat(token.image);}
		| <PUT>{ elreturn=elreturn.concat(token.image);}" :"{ elreturn=elreturn.concat(token.image);}(<BALLOONS>|<CHIPS>) { elreturn=elreturn.concat(token.image);}" "{ elreturn=elreturn.concat(token.image);} x=checkNum(tempnombres, tempvalores)
		| <PICK>{ elreturn=elreturn.concat(token.image);}" :"{ elreturn=elreturn.concat(token.image);}(<BALLOONS>|<CHIPS>){ elreturn=elreturn.concat(token.image);} " "{ elreturn=elreturn.concat(token.image);} x=checkNum(tempnombres, tempvalores)
		| <MOVE_DIR>{ elreturn=elreturn.concat(token.image);} x=checkNum(tempnombres, tempvalores) (<FRONT>|<RIGHT>|<LEFT>|<BACK>){ elreturn=elreturn.concat(token.image);}
		| <RUN_DIRS>{ elreturn=elreturn.concat(token.image);}(<FRONT>{ elreturn=elreturn.concat(token.image);}|<RIGHT>{ elreturn=elreturn.concat(token.image);}|<LEFT>{ elreturn=elreturn.concat(token.image);}|<BACK>{ elreturn=elreturn.concat(token.image);})+ 
		| <MOVE_FACE> { elreturn=elreturn.concat(token.image);}x=checkNum(tempnombres, valorvars) (<SOUTH>|<WEST>|<EAST>|<NORTH>){ elreturn=elreturn.concat(token.image);}
		| <DEFVAR> { elreturn=elreturn.concat(token.image);}" "{ elreturn=elreturn.concat(token.image);} declararVariable(tempnombres, valorvars) { elreturn=elreturn.concat(token.image);}//{variables[Integer.parseInt(nueva[0])]=nueva[1];valorvars[Integer.parseInt(nueva[0])]=Integer.parseInt(nueva[2]);}
		| <IF>{ elreturn=elreturn.concat(token.image);}bool=condition()
		| < EOF>
		| (< OP>{ elreturn=elreturn.concat(token.image);}(soloRevisaIf(x, salida, tempnombres, tempvalores))< CP >{ elreturn=elreturn.concat(token.image);})+
		)
	
	  //[< OP>{ elreturn=elreturn.concat(token.image);}
	  //soloRevisaIfRecursion(x, salida, tempnombres, tempvalores)]
}



void cargarFuncion(ArrayList<String> tempnombres, ArrayList<Integer> tempvalores, ArrayList<String> nombrefuns, ArrayList<String> paramfuns, ArrayList<String> blockfuns) :
{
  String parametros = "";
  String agregastr = "";
  int agregaint = 0;
  int x = 0;
  String salida = "";
  String elrelleno = "";
  String elrenombre = "";
}
{
  (    //< NAME>|< LETRA>
    (< LETRA >{ elrenombre=elrenombre.concat(token.image);})(< LETRA >{ elrenombre=elrenombre.concat(token.image);}|< DIGITO >{ elrenombre=elrenombre.concat(token.image);})*
  )
  {
    try 
			{
			  	nombrefuns.add(elrenombre);
			  	System.out.println(elrenombre);
				
			} 
			catch (NumberFormatException ee) 
			{
				// Dada la forma de NUMERO, sabemos que solo puede tener d�gitos
				// Por lo tanto, lo unico que podria pasar es que el numero sea muy grande
				throw new Error("NO PUDE METER EN EL ARRAY ESTO: "+token.image+"!!");
			}
  }
  " "
  < OP>
  (
    //< NAME>|< LETRA>
    (< LETRA >)(< LETRA >|< DIGITO >)*
  )
  {
    
  	try 
			{
			  	tempnombres.add(token.image);
				tempvalores.add(4);
				parametros = parametros.concat(token.image);
			} 
			catch (NumberFormatException ee) 
			{
				// Dada la forma de NUMERO, sabemos que solo puede tener d�gitos
				// Por lo tanto, lo unico que podria pasar es que el numero sea muy grande
				throw new Error("NO PUDE METER EN EL ARRAY ESTO: "+token.image+"!!");
			}
	}
  (
    " "
    (
    //< NAME>|< LETRA>
    (< LETRA >)(< LETRA >|< DIGITO >)*
  	)
    {
    
  		try 
			{
			  	tempnombres.add(token.image);
				tempvalores.add(4);
				parametros = parametros.concat(" ");
				parametros = parametros.concat(token.image);
			} 
			catch (NumberFormatException ee) 
			{
				// Dada la forma de NUMERO, sabemos que solo puede tener d�gitos
				// Por lo tanto, lo unico que podria pasar es que el numero sea muy grande
				throw new Error("NO PUDE METER EN EL ARRAY ESTO: "+token.image+"!!");
			}
	}  )*
  < CP>
  {
    for(x=0; x<variables.size(); x++)
    {
      agregastr = variables.get(x);
      agregaint = valorvars.get(x);
      tempnombres.add(agregastr);
	  tempvalores.add(agregaint);
     }
     elreturn = "";
  }
  < OP > { elreturn = token.image;}
  soloRevisaIf(x,salida,tempnombres, tempvalores)
  < CP>
  {
    elreturn = elreturn.concat(token.image);
    paramfuns.add(parametros);
    System.out.println(parametros);
    blockfuns.add(elreturn);
    System.out.println(elreturn);
    
  }
  
}



	int numero() throws Error:
	{
	  
		int total=1;
	}
	{
		<NUMERO>
		{
			try 
			{
				total = Integer.parseInt(token.image);
			} 
			catch (NumberFormatException ee) 
			{
				// Dada la forma de NUMERO, sabemos que solo puede tener d�gitos
				// Por lo tanto, lo unico que podria pasar es que el numero sea muy grande
				throw new Error("Number out of bounds: "+token.image+"!!");
			}
			return total;
		}
	}


	




boolean condition ():

{
  int x=0;
  boolean bool;
}
{
	<OP>

	(  		<FACING_P>{ elreturn=elreturn.concat(token.image);}
  				" : "{ elreturn=elreturn.concat(token.image);}
  				(bool=facing_p(){if (bool){return true;}else{return false;}})
		| <CAN_PUT_P>" "
					(<BALLOONS>" "x=checkNum(variables, valorvars)
							{
					  			if(world.getMyBalloons() >= x)
					  			{
					  			  return true;
					  			}
					  			else
					  			{
					  			  return false;
					  			}
							}
					|<CHIPS>" "x=checkNum(variables, valorvars)
							{
					  		if(world.getMyChips() >= x && world.freeSpacesForChips() >= x)
					  		{
					  		  return true;
					  		}
					  		else
					  		{
					  		  return false;
					 		 }
							})
		| <CAN_MOVE_P>" "(<SOUTH>
					{
					  //String posx= String.valueOf(world.getPosition().getX());
					 // String posy= String.valueOf(world.getPosition().getY()-1);
					 
					  
					  //if(world.isBlocked(new Point(Integer.parseInt(posx),Integer.parseInt(posy))))
					  int posx = (int)world.getPosition().getX();
					  int posy=(int)world.getPosition().getY();
					  if(world.blockedInRange(posx,posy,-1,1))
					  {
					    return true;
					  }
					   else
					  {
					    return false;
					  }
					}
				    /*|<WEST>
				    {
				       String posx= String.valueOf(world.getPosition().getX()-1);
				      String posy= String.valueOf(world.getPosition().getY());
				      
				      if(world.isBlocked(new Point(Integer.parseInt(posx),Integer.parseInt(posy))))
					  {
					    return true;
					  }
					   else
					  {
					    return false;
					  }
					}
					
					|<EAST>
					{
					  posx= String.valueOf(world.getPosition().getX()+1);
				      posy= String.valueOf(world.getPosition().getY());
					  if(world.isBlocked(new Point(Integer.parseInt(posx),Integer.parseInt(posy))))
					  {
					    return true;
					  }
					   else
					  {
					    return false;
					  }
					}*/
					
					|<NORTH>
				    {
					  //posx= String.valueOf(world.getPosition().getX());
				     // posy= String.valueOf(world.getPosition().getY()+1);
					  //if(world.isBlocked(new Point(Integer.parseInt(posx),Integer.parseInt(posy))))
					  posx = (int)world.getPosition().getX();
					  posy=(int)world.getPosition().getY();
					  if(world.blockedInRange(posx,posy,1,0))
					  {
					    return true;
					  }
					   else
					  {
					    return false;
					  }
				    }
					)

/*| <CAN_PICK_P>" "(<BALLOONS>|<CHIPS>) x=checkNum(variables, valorvars)
|<DEFUN> " " cargarFuncion(tempnombres, tempvalores, nombrefuns, paramfuns, blockfuns)
| <NOT> condition()


)*/
)
 
}




 boolean facing_p():
{
  int x=1;
  boolean bool;
}
{
 
  (<SOUTH>
  { elreturn=elreturn.concat(token.image);
    if (world.facingSouth())
	  {

	    bool=true;
	    return bool;
	    
	  }
	else
	{
		 bool=false;
	    return bool;
	}
  }
| <WEST>
	{elreturn=elreturn.concat(token.image);
	  if (world.facingWest())
		  {
		     bool=true;
	         return bool;
		  }
		else
		{
			 bool=false;
	    	return bool;
		}
	  }
|<EAST>
	{elreturn=elreturn.concat(token.image);
	  if (world.facingEast())
		  {
		     bool=true;
	         return bool;
		  }
		else
		{
			 bool=false;
	    	return bool;
		}
	  }
| <NORTH>

	{elreturn=elreturn.concat(token.image);
	  if (world.facingNorth())
		  {
		    bool=true;
	         return bool;
		  }
	 else
	 {
		 bool=false;
	    return bool;
     }
	 }
)

}

void cambiarVariable(ArrayList<String> variables, ArrayList<Integer> valorvars) :
{
  int pos=-40;
  int i = 0;
  String pru = "";
}
{
  (    //<NAME>|< LETRA>
    (< LETRA >{elreturn= elreturn.concat(token.image);})(< LETRA >{ elreturn=elreturn.concat(token.image);}|< DIGITO >{ elreturn=elreturn.concat(token.image);})*
  )
  {
    for(i=0; i<variables.size(); i++)
  	{
  	  pru = variables.get(i);
  	  if (pru!=null)
  	  { 
    	if(token.image.equals(pru))
    	{
    	  variables.remove(i);
    	  valorvars.remove(i);
    	  variables.add(token.image);
    	  pos = i;
    	}
  	  }
  	}
  	if(pos==-40)
  	{
  	  throw new Error("ERROR: NO EXISTE LA VARIABLE");

  	}
  	
  }
  " "{ elreturn=elreturn.concat(token.image);}
  <NUMERO>
  {
    valorvars.add(Integer.parseInt(token.image));
    elreturn=elreturn.concat(token.image);
  }

}

int checkNum(ArrayList<String> variables, ArrayList<Integer> valorvars) :
{
  int rta = -57;
  int i = 0;
}
{
  (
    //< NAME>
    (< LETRA >{ elreturn=elreturn.concat(token.image);})(< LETRA >{ elreturn=elreturn.concat(token.image);}|< DIGITO >{ elreturn=elreturn.concat(token.image);})*
  {
    
  
  	for(i=0; i<variables.size(); i++)
  	{
    	if(token.image.equals(variables.get(i)))
    	{
    	  rta= valorvars.get(i);

    	}
  	}
  	if(rta == -57)
  	{
  	  throw new Error("ERROR: NO EXISTE LA VARIABLE");

  	}
  	return rta;
  }
	|  < NUMERO>
	{
	  rta=Integer.parseInt(token.image);
	  elreturn=elreturn.concat(token.image);
	  return rta; 
	}
	)
}




void declararVariable(ArrayList<String> variables, ArrayList<Integer> valorvars) :
	{
	  String nombre = "";
	  int total = 1;
	  int pos = 0;
	  int j = 0;
	  int k = 0;
	  
	}
	{
	  (	    //< NAME>|< LETRA>
	    (< LETRA >{ elreturn=elreturn.concat(token.image);})(< LETRA >{ elreturn=elreturn.concat(token.image);}|< DIGITO >{ elreturn=elreturn.concat(token.image);})*
	  )
	  {
	    try 
			{
			  	variables.add(token.image);
				
			} 
			catch (NumberFormatException ee) 
			{
				// Dada la forma de NUMERO, sabemos que solo puede tener d�gitos
				// Por lo tanto, lo unico que podria pasar es que el numero sea muy grande
				throw new Error("NO PUDE METER EN EL ARRAY ESTO: "+token.image+"!!");
			}

	  }
	  " "
	  <NUMERO>
		{
			try 
			{
			  total = Integer.parseInt(token.image);
			  valorvars.add(total);
			  

				
			} 
			catch (NumberFormatException ee) 
			{
				// Dada la forma de NUMERO, sabemos que solo puede tener d�gitos
				// Por lo tanto, lo unico que podria pasar es que el numero sea muy grande
				throw new Error("Number out of bounds: "+token.image+"!!");
			}
			
			
		}
	}
	