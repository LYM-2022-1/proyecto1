/*
Gramatica para el Robot:
Autor: Alejandro Arango
Modificado por: Silvia Takahashi
Modificado por: Juan Pablo Morales.
Agregadas producciones para manejar globos
Modificado por Silvia Takahashi
Eliminadas producciones para manejar globos
Agregado el esqueleto para la traduccion
Modificado por Silvia Takahashi 
Re: Agregar Reglas para el manejo de globos
Modificado por Saulo Daza y Sonia Vivas
Modificado por Silvia Takahashi
Eliminadas reglas de traducci�n DE  MARCROS
Cambio del lenguaje de comandos
Modificado por Silvia Takahashi: algunas Reglas para traduccion
Modificado por Silvia Takahashi: Cambio en el lenguaje
Abril: 2008 - Simplificado apra solo interpretaci�n
 **/

options 
{
	LOOKAHEAD=1; 
	IGNORE_CASE=true;
	STATIC = false;
	
}
   

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import java.awt.Point;
import java.io.*;
import java.util.Vector;
import java.util.LinkedList;
import java.util.ArrayList;
//import control.Interpreter;

@SuppressWarnings("serial")
public class Robot 
{


	private RobotWorldDec world;
	private RobotWorld world2;
	//private Interpreter recursividad = new Interpreter();
	private ArrayList<String> variables = new ArrayList<String>();
	private ArrayList<Integer> valorvars = new ArrayList<Integer>();
	private ArrayList<String> tempnombres = new ArrayList<String>();
	private ArrayList<Integer> tempvalores = new ArrayList<Integer>();
	private ArrayList<String> blockfuns = new ArrayList<String>();
	private ArrayList<String> nombrefuns = new ArrayList<String>();
	private ArrayList<String> paramfuns = new ArrayList<String>();
	
	private int cuentaif = -1;
	void setWorld(RobotWorldDec w) {
		world = (RobotWorldDec) w;	
	}
	/*void setWorld2(RobotWorld w2) {
		world2 = (RobotWorld) w2;	
	}*/
	

	String salida=new String();
}
PARSER_END(Robot)

SKIP:
{
	"\r"
	|	"\t"
	//| "\n"
}

TOKEN: /* Nombres de Comandos */
{

			<MOVE:  "move">
		| 	<TURNRIGHT: "turnright">
		| 	<PUT: "put">
		| 	<PICK: "pick">
		| < DEFVAR: "defvar">
		|  <EQUALS: "=" >
		|  <TURN: "turn" >
		|  <FACE: "face" >
		|  <MOVE_DIR: "move-dir" >
		|  <RUN_DIRS: "run-dirs" >
		|  <MOVE_FACE: "move-face" >
		|  <IF: "if" >
		|  <LOOP: "loop" >
		|  <REPEAT: "repeat" >
		|  <DEFUN: "defun" >
		|  <FACING_P: "facing-p" >
		|  <CAN_PUT_P: "can-put-p" >
		|  <CAN_PICK_P: "can-pick-p" >
		|  <CAN_MOVE_P: "can-move-p" >
		|  <NOT: "not" >
		| < PASS:"skip">
		|  <OP: "(" >
		|  <CP: ")" >
		
	
		

}
TOKEN : /* PARAMETROS */
{
		<BALLOONS:  "balloons" >
		|	<CHIPS:     "chips"  >
		|  <RIGHT: "right" >
		|  <LEFT: "left" >
		|  <AROUND: "around" >
		|  <BACK: "back" >
		|  <FRONT: "front" >
		|  <NORTH: "north" >
		|  <SOUTH: "south" >
		|  <WEST: "west" >
		|  <EAST: "east" >

}

TOKEN :
{
		<NUMERO: (<DIGIT>)+ >
		|  	<#DIGIT: ["0"-"9"] >
}


TOKEN:
{
  	
  	< LETRA: ["a"-"z","A"-"Z"]>
 	| <DIGITO: ["0"-"9"] >
 	//| < NAME: (< LETRA >)(< LETRA >|< DIGITO >)*>
 	//| < LETRA: (< letra >)(< letra >|< digito >)*>
}




boolean command(StringBuffer sistema) :
	{	
		int x = 0;
		salida=new String();
		String[] nueva= new String[3];
		
	}
	
	{

		/*(
		   <TURNRIGHT> "(" ")" {world.turnRight();salida = "Command: Turnright";}
		| 	<MOVE>  "(" x=numero() ")" {world.moveForward(x);salida = "Command: Moveforward ";}  
	    | < DEFVAR> " " declararVariable(variables, valorvars) ")"
		) "\n" */ 
		haceInput(x, salida, nueva) 

		{
		  //  try {
	    	//		 Thread.sleep(1);
	    	  //   } catch (InterruptedException e) {
	    		//	        System.err.format("IOException: %s%n", e);
	    		//	    }
	    			 
			sistema.append(salida);
			return true;
		}

     |  "po" { return true; }

		| <EOF> {return false;} 
	}

void haceInput(int x, String salida, String[] nueva):
{
  int p = 0;
  boolean bool;
 		
 }
{
  	
  	  <OP>
	(
   		<EQUALS> " " cambiarVariable(variables, valorvars) 
		| <MOVE>" " x=checkNum(variables, valorvars) {world.moveHorizontally(x);salida = "Command: Moveforward ";}
		| <TURN>":"(<LEFT>|<AROUND>|<RIGHT>) 
		| <FACE>":"(<SOUTH>|<WEST>|<EAST>|<NORTH>)
		| <PUT>":"
					 (<BALLOONS>x=checkNum(variables, valorvars){world.putBalloons(x);}
					  |<CHIPS>x=checkNum(variables, valorvars){world.putChips(x);})
		| <PICK>":"(<BALLOONS>x=checkNum(variables, valorvars){world.grabBalloons(x);}
					  |<CHIPS>x=checkNum(variables, valorvars){world.pickChips(x);})
		| <MOVE_DIR> x=checkNum(variables, valorvars) (<FRONT>|<RIGHT>|<LEFT>|<BACK>)
		| <RUN_DIRS>(<FRONT>|<RIGHT>|<LEFT>|<BACK>)+ //FALTA QUE VUELVA A POSCICION ORIGINAL
		| <MOVE_FACE> x=checkNum(variables, valorvars) (<SOUTH>|<WEST>|<EAST>|<NORTH>)
		| <DEFVAR> " " declararVariable(variables, valorvars) //{variables[Integer.parseInt(nueva[0])]=nueva[1];valorvars[Integer.parseInt(nueva[0])]=Integer.parseInt(nueva[2]);}
		| < DEFUN> " " cargarFuncion(tempnombres, tempvalores, nombrefuns, paramfuns, blockfuns)
		| (<IF> (bool=condition()
				{
				  if(bool)
				  {
				    throw new Error("si es verdad");
				  }
				  else
				  {
				     throw new Error("no es verdad");
				  }
				}
				| <CAN_PUT_P>" "(<BALLOONS>|<CHIPS>) x=checkNum(variables, valorvars)
				| <CAN_PICK_P>" "(<BALLOONS>|<CHIPS>) x=checkNum(variables, valorvars)
		         )
			

		)
		|buscarFuncion() 
		

	)
	
	
	<CP>
    
}

void buscarFuncion():
{
  int x=0;
  boolean cheker=false;
  
}
{
  (
    //< NAME>|< LETRA>
    (< LETRA >)(< LETRA >|< DIGITO >)*
  )
  {
    try 
			{
			  	for(x=0; x<nombrefuns.size(); x++)
    			{
      				if(token.image.equals(nombrefuns.get(x)))
      				{
      				  cheker=true;

      				}
     			}
     			if(!cheker)
     			{
     			  throw new Error("NO ENCONTRE ESA FUNCION... PAILA ");

     			}
			} 
			catch (NumberFormatException ee) 
			{
				// Dada la forma de NUMERO, sabemos que solo puede tener d�gitos
				// Por lo tanto, lo unico que podria pasar es que el numero sea muy grande
				throw new Error("NO PUDE METER EN EL ARRAY ESTO: "+token.image+"!!");
			}
  }
  (
    < NUMERO>
    {

    }  )
  (
    " "
    < NUMERO>  )
  
}

void soloRevisa(int x, String salida, ArrayList<String> tempnombres, ArrayList<Integer> tempvalores):
{
  int p = 0;
  boolean bool;
 		
 }
{
  	
  	  <OP>
	(
   		<EQUALS> " " cambiarVariable(tempnombres, tempvalores) 
		| <MOVE>" " x=checkNum(tempnombres, tempvalores)// {world.moveHorizontally(x);salida = "Command: Moveforward ";}
		| <TURN>":"(<LEFT>|<AROUND>|<RIGHT>) 
		| <FACE>":"(<SOUTH>|<WEST>|<EAST>|<NORTH>)
		| <PUT>" :"(<BALLOONS>|<CHIPS>) " " x=checkNum(tempnombres, tempvalores)
		| <PICK>" :"(<BALLOONS>|<CHIPS>) " " x=checkNum(tempnombres, tempvalores)
		| <MOVE_DIR> x=checkNum(tempnombres, tempvalores) (<FRONT>|<RIGHT>|<LEFT>|<BACK>)
		| <RUN_DIRS>(<FRONT>|<RIGHT>|<LEFT>|<BACK>)+ //FALTA QUE VUELVA A POSCICION ORIGINAL
		| <MOVE_FACE> x=checkNum(tempnombres, valorvars) (<SOUTH>|<WEST>|<EAST>|<NORTH>)
		| <DEFVAR> " " declararVariable(tempnombres, valorvars) //{variables[Integer.parseInt(nueva[0])]=nueva[1];valorvars[Integer.parseInt(nueva[0])]=Integer.parseInt(nueva[2]);}
		| <DEFUN> " " cargarFuncion(tempnombres, tempvalores, nombrefuns, paramfuns, blockfuns)
		| <IF>bool=condition()
		| (soloRevisa(x, salida, tempnombres, tempvalores))+
	)
	
	
		  <CP>
    
}

void cargarFuncion(ArrayList<String> tempnombres, ArrayList<Integer> tempvalores, ArrayList<String> nombrefuns, ArrayList<String> paramfuns, ArrayList<String> blockfuns) :
{
  String parametros = "";
  String agregastr = "";
  int agregaint = 0;
  int x = 0;
  String salida = "";
}
{
  (    //< NAME>|< LETRA>
    (< LETRA >)(< LETRA >|< DIGITO >)*
  )
  {
    try 
			{
			  	nombrefuns.add(token.image);
				
			} 
			catch (NumberFormatException ee) 
			{
				// Dada la forma de NUMERO, sabemos que solo puede tener d�gitos
				// Por lo tanto, lo unico que podria pasar es que el numero sea muy grande
				throw new Error("NO PUDE METER EN EL ARRAY ESTO: "+token.image+"!!");
			}
  }
  " "
  < OP>
  (
    //< NAME>|< LETRA>
    (< LETRA >)(< LETRA >|< DIGITO >)*
  )
  {
    
  	try 
			{
			  	tempnombres.add(token.image);
				tempvalores.add(4);
				parametros = parametros.concat(token.image);
			} 
			catch (NumberFormatException ee) 
			{
				// Dada la forma de NUMERO, sabemos que solo puede tener d�gitos
				// Por lo tanto, lo unico que podria pasar es que el numero sea muy grande
				throw new Error("NO PUDE METER EN EL ARRAY ESTO: "+token.image+"!!");
			}
	}
  (
    " "
    (
    //< NAME>|< LETRA>
    (< LETRA >)(< LETRA >|< DIGITO >)*
  	)
    {
    
  		try 
			{
			  	tempnombres.add(token.image);
				tempvalores.add(4);
				parametros = parametros.concat(" ");
				parametros = parametros.concat(token.image);
			} 
			catch (NumberFormatException ee) 
			{
				// Dada la forma de NUMERO, sabemos que solo puede tener d�gitos
				// Por lo tanto, lo unico que podria pasar es que el numero sea muy grande
				throw new Error("NO PUDE METER EN EL ARRAY ESTO: "+token.image+"!!");
			}
	}  )*
  < CP>
  {
    for(x=0; x<variables.size(); x++)
    {
      agregastr = variables.get(x);
      agregaint = valorvars.get(x);
      tempnombres.add(agregastr);
	  tempvalores.add(agregaint);
     }
  }
  soloRevisa(x,salida,tempnombres, tempvalores)
  {
    //blockfuns
    paramfuns.add(parametros);
    blockfuns.add(token.image);
    
  }
  
}



	int numero() throws Error:
	{
	  
		int total=1;
	}
	{
		<NUMERO>
		{
			try 
			{
				total = Integer.parseInt(token.image);
			} 
			catch (NumberFormatException ee) 
			{
				// Dada la forma de NUMERO, sabemos que solo puede tener d�gitos
				// Por lo tanto, lo unico que podria pasar es que el numero sea muy grande
				throw new Error("Number out of bounds: "+token.image+"!!");
			}
			return total;
		}
	}


	




boolean condition ():

{
  int x=0;
  boolean bool;
}
{
 <OP>

  
(  <FACING_P>" : " (bool=facing_p()
				{ if (bool)
				  {
					  return true;
					  
				  }
				  else
				  {
				    return false;
				    
				    
				  }
				}
	                         )
//| <CAN_PUT_P>" "(<BALLOONS>|<CHIPS>) x=checkNum(variables, valorvars)
/*| <CAN_PICK_P>" "(<BALLOONS>|<CHIPS>) x=checkNum(variables, valorvars)
| <CAN_MOVE_P>" "(<SOUTH>|<WEST>|<EAST>|<NORTH>)
|<DEFUN> " " cargarFuncion(tempnombres, tempvalores, nombrefuns, paramfuns, blockfuns)
| <NOT> condition()


)*/
)
 <CP>
}




 boolean facing_p():
{
  int x=1;
  boolean bool;
}
{
 
  (<SOUTH>
  {if (world.facingSouth())
	  {

	    bool=true;
	    return bool;
	    
	  }
	else
	{
		 bool=false;
	    return bool;
	}
  }
| <WEST>
	{if (world.facingWest())
		  {
		     bool=true;
	         return bool;
		  }
		else
		{
			 bool=false;
	    	return bool;
		}
	  }
|<EAST>
	{if (world.facingEast())
		  {
		     bool=true;
	         return bool;
		  }
		else
		{
			 bool=false;
	    	return bool;
		}
	  }
| <NORTH>

	{if (world.facingNorth())
		  {
		    bool=true;
	         return bool;
		  }
	 else
	 {
		 bool=false;
	    return bool;
     }
	 }
)

}

void cambiarVariable(ArrayList<String> variables, ArrayList<Integer> valorvars) :
{
  int pos=-40;
  int i = 0;
  String pru = "";
}
{
  (    //<NAME>|< LETRA>
    (< LETRA >)(< LETRA >|< DIGITO >)*
  )
  {
    for(i=0; i<variables.size(); i++)
  	{
  	  pru = variables.get(i);
  	  if (pru!=null)
  	  { 
    	if(token.image.equals(pru))
    	{
    	  variables.remove(i);
    	  valorvars.remove(i);
    	  variables.add(token.image);
    	  pos = i;
    	}
  	  }
  	}
  	if(pos==-40)
  	{
  	  throw new Error("ERROR: NO EXISTE LA VARIABLE");

  	}
  	
  }
  " "
  <NUMERO>
  {
    valorvars.add(Integer.parseInt(token.image));
  }

}

int checkNum(ArrayList<String> variables, ArrayList<Integer> valorvars) :
{
  int rta = -57;
  int i = 0;
}
{
  (
    //< NAME>
    (< LETRA >)(< LETRA >|< DIGITO >)*
  {
    
  
  	for(i=0; i<variables.size(); i++)
  	{
    	if(token.image.equals(variables.get(i)))
    	{
    	  rta= valorvars.get(i);

    	}
  	}
  	if(rta == -57)
  	{
  	  throw new Error("ERROR: NO EXISTE LA VARIABLE");

  	}
  	return rta;
  }
	|  < NUMERO>
	{
	  rta=Integer.parseInt(token.image);
	  return rta; 
	}
	)
}




void declararVariable(ArrayList<String> variables, ArrayList<Integer> valorvars) :
	{
	  String nombre = "";
	  int total = 1;
	  int pos = 0;
	  int j = 0;
	  int k = 0;
	  
	}
	{
	  (	    //< NAME>|< LETRA>
	    (< LETRA >)(< LETRA >|< DIGITO >)*
	  )
	  {
	    try 
			{
			  	variables.add(token.image);
				
			} 
			catch (NumberFormatException ee) 
			{
				// Dada la forma de NUMERO, sabemos que solo puede tener d�gitos
				// Por lo tanto, lo unico que podria pasar es que el numero sea muy grande
				throw new Error("NO PUDE METER EN EL ARRAY ESTO: "+token.image+"!!");
			}

	  }
	  " "
	  <NUMERO>
		{
			try 
			{
			  total = Integer.parseInt(token.image);
			  valorvars.add(total);
			  

				
			} 
			catch (NumberFormatException ee) 
			{
				// Dada la forma de NUMERO, sabemos que solo puede tener d�gitos
				// Por lo tanto, lo unico que podria pasar es que el numero sea muy grande
				throw new Error("Number out of bounds: "+token.image+"!!");
			}
			
			
		}
	}
	